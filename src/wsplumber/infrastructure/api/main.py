from fastapi import FastAPI, HTTPException, BackgroundTasks, WebSocket, WebSocketDisconnect
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from datetime import datetime
import psutil
import os
from pathlib import Path
from typing import List, Optional
from wsplumber.infrastructure.api.background import SimulationManager

app = FastAPI(
    title="WSPlumber API",
    description="Management API for Wall Street Plumber Trading Engine",
    version="0.1.0"
)

sim_manager = SimulationManager()

class BacktestRequest(BaseModel):
    csv_path: str
    initial_balance: float = 10000.0

class BacktestStatus(BaseModel):
    task_id: str
    status: str
    progress: float
    tick_count: int
    error: Optional[str] = None
    result: Optional[dict] = None

@app.get("/health")
async def health_check():
    """Basic health monitoring and system stats."""
    process = psutil.Process(os.getpid())
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "0.1.0",
        "system": {
            "cpu_percent": psutil.cpu_percent(),
            "memory_usage_mb": process.memory_info().rss / 1024 / 1024,
            "os": os.name
        }
    }

@app.get("/reports", response_model=List[str])
async def list_reports():
    """List all audit reports generated by the system."""
    reports_dir = Path(".")
    reports = [f.name for f in reports_dir.glob("audit_report_*.txt")]
    return sorted(reports, reverse=True)

@app.get("/reports/{filename}")
async def get_report(filename: str):
    """View or download a specific audit report."""
    if not filename.startswith("audit_report_") or not filename.endswith(".txt"):
        raise HTTPException(status_code=400, detail="Invalid report filename")
    
    file_path = Path(filename)
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Report not found")
    
    return FileResponse(path=file_path, filename=filename, media_type="text/plain")

@app.get("/charts", response_model=List[str])
async def list_charts():
    """List all audit charts generated by the system."""
    charts_dir = Path(".")
    charts = [f.name for f in charts_dir.glob("audit_chart_*.png")]
    return sorted(charts, reverse=True)

@app.get("/charts/{filename}")
async def get_chart(filename: str):
    """View or download a specific audit chart."""
    if not filename.startswith("audit_chart_") or not filename.endswith(".png"):
        raise HTTPException(status_code=400, detail="Invalid chart filename")
    
    file_path = Path(filename)
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Chart not found")
    
    return FileResponse(path=file_path, filename=filename, media_type="image/png")

@app.post("/backtest/run", status_code=202)
async def run_backtest(request: BacktestRequest, background_tasks: BackgroundTasks):
    """Start a backtest simulation in the background."""
    if not Path(request.csv_path).exists():
        raise HTTPException(status_code=400, detail=f"File not found: {request.csv_path}")
    
    task_id = sim_manager.create_task(request.csv_path)
    background_tasks.add_task(
        sim_manager.run_simulation, 
        task_id, 
        request.csv_path, 
        request.initial_balance
    )
    
    return {"task_id": task_id, "status": "pending"}

@app.get("/backtest/{task_id}", response_model=BacktestStatus)
async def get_backtest_status(task_id: str):
    """Get the current status of a backtest task."""
    if task_id not in sim_manager.tasks:
        raise HTTPException(status_code=404, detail="Task not found")
    
    task = sim_manager.tasks[task_id]
    return BacktestStatus(
        task_id=task.task_id,
        status=task.status,
        progress=task.progress,
        tick_count=task.tick_count,
        error=task.error,
        result=task.result if task.status == "completed" else None
    )

@app.websocket("/ws/{task_id}")
async def websocket_endpoint(websocket: WebSocket, task_id: str):
    """Real-time monitoring of a specific backtest via WebSocket."""
    if task_id not in sim_manager.tasks:
        await websocket.close(code=4044)
        return

    await websocket.accept()
    
    # Create a dedicated queue for this connection
    queue = asyncio.Queue()
    if task_id not in sim_manager.subscribers:
        sim_manager.subscribers[task_id] = []
    sim_manager.subscribers[task_id].append(queue)
    
    try:
        while True:
            # Wait for messages from the simulation
            message = await queue.get()
            await websocket.send_json(message)
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for task {task_id}")
    finally:
        # Cleanup
        if task_id in sim_manager.subscribers:
            sim_manager.subscribers[task_id].remove(queue)
            if not sim_manager.subscribers[task_id]:
                del sim_manager.subscribers[task_id]

@app.get("/")
async def root():
    return {
        "message": "WSPlumber API is running",
        "endpoints": {
            "health": "/health",
            "reports": "/reports",
            "charts": "/charts",
            "docs": "/docs"
        },
        "status": "online"
    }
